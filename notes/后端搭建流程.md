
# 创建Nest项目
```markdown
nest new backend -s -g -p pnpm
```
# 安装所需依赖
```markdown
pnpm i @nestjs/config @nestjs/jwt @nestjs/passport passport passport-jwt bcrypt prisma @prisma/client redis ioredis
```

- `@nestjs/jwt` + `passport-jwt`用于JWT登录认证
- `bcrypt` 密码加密
- `prisma` + `@prisma/client` 数据库ORM
- `redis` + `ioredis` 缓存

# docker启动服务

> 定义docker-compose.yml

```yaml
version: "3.8" # 指定docker-compose的版本
services: 
  # 数据库
  db: 
    image: mysql:8 # 使用官方mysql8的镜像
    container_name: blog # 容器名称
    restart: always # 容器异常退出时自动重启
    # 配置MYSQL环境变量
    environment:
      MYSQL_ROOT_PASSWORD: 123456 # root用户密码
      MYSQL_DATABASE: blog-mysql # 容器启动时自动创建数据库blog
      # MYSQL_USER: bloguser # 普通用户
      # MYSQL_PASSWORD: blogpass # 普通用户密码
    ports:
      - "3306:3306" # 把容器的3306端口映射到本机的3306端口
    # 数据持久化.把MYSQL数据存储到宿主机,避免容器删掉后数据丢失
    volumes:
      - blog-mysql-data:/var/lib/mysql

  # redis
  redis:
    image: redis:7 # 使用官方redis7镜像
    container_name: blog-redis # 容器名称
    ports:
      - "6379:6379" # 把容器的6379端口映射到本机的6379端口

volumes:
  blog-mysql-data: # 卷, 用于MYSQL数据持久化
```

> 执行docker-compose up -d

# 集成prisma

## 1.手动初始化prisma

```markdown
npx prisma init
```
> 执行后,会在根目录生成prisma文件夹,文件夹中存在`schema.prisma`数据库schema定义文件. 生成的目录结构如下:

```markdown
backend/
 ├─ prisma/
 │   └─ schema.prisma   # 数据库 schema 定义文件
 └─ .env                # 数据库连接配置
```

## 2.配置数据库连接

> 修改.env环境文件

```js
DATABASE_URL="mysql://root:123456@127.0.0.1:3306/blog-mysql"
```

- `root` 你mysql的用户名
- `123456` mysql密码
- `127.0.0.1:3306`你docker暴露的端口
- `blog-mysql` 数据库名

## 3.定义用户模型

```mysql
// prisma/schame.prisma

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "mysql"
  url      = env("DATABASE_URL")
}

model User {
  id        Int      @id @default(autoincrement())
  username  String   @unique
  email     String   @unique
  password  String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}
```

## 4.迁移数据库

```markdown
npx prisma migrate dev --name init // 执行后会在数据库中创建User表.
```

## 5.在Nest中集成Prisma

> 首先需要从@prisma/client中导入 `PrismaClient`所以需要先执行 npx prisma generate后, node_module里才会生成, schame每变动一次都要重新生成一次.

```ts
import { Injectable, OnModuleInit, OnModuleDestroy } from '@nestjs/common';
import { PrismaClient } from '@prisma/client';

@Injectable()
export class PrismaService
  extends PrismaClient
  implements OnModuleInit, OnModuleDestroy
{
  async onModuleInit() {
    await this.$connect();
  }

  async onModuleDestroy() {
    await this.$disconnect();
  }
}
```

## 6.创建prisma模块

> 创建prisma.module.ts

```ts
import { Global, Module } from '@nestjs/common';
import { PrismaService } from './prisma.service';

@Global() // 声明为全局模块
@Module({
  providers: [PrismaService],
  exports: [PrismaService],
})
export class PrismaModule {}
```

## 7.AppModule里引入

```ts
import { Module } from '@nestjs/common';
import { AppController } from './app.controller';
import { AppService } from './app.service';
import { PrismaModule } from '../prisma/prisma.module';

@Module({
  imports: [PrismaModule],
  controllers: [AppController],
  providers: [AppService],
  exports: [],
})
export class AppModule {}

```

## 7.运行项目

> pnpm run start:dev即可.

# 用户模块与权限模块

> 使用NestCLI生成user与auth模块

```markdown
// 生成用户模块增删改查
nest generate resource user --no-spec

// 生成权限模块增删改查
nest generate resource auth --no-spec
```

> 执行后,src根目录下会生成对应的controller,service,module,dto,entities等文件.

## 用户模块

> user.module.ts

```ts
import { Module } from '@nestjs/common';
import { UserService } from './user.service';
import { UserController } from './user.controller';

@Module({
  controllers: [UserController],
  providers: [UserService],
})
export class UserModule {}
```

> user.controller.ts

```ts
import { Controller } from '@nestjs/common';
import { UserService } from './user.service';

@Controller('user')
export class UserController {
  constructor(private readonly userService: UserService) {}
}
```

> user.service.ts

```ts
import { Injectable } from '@nestjs/common';
import { PrismaService } from 'prisma/prisma.service'; // 引入prismaService用户操作数据库
import * as bcrypt from 'bcrypt'; // 对密码进行加密
import type { User } from '@prisma/client'; // 用于函数返回值类型
import { CreateUserDto } from './dto/create-user.dto'; // 创建用户模型与参数校验

@Injectable()
export class UserService {
  constructor(private readonly prismaService: PrismaService) {}

  // 创建用户
  async create(dto: CreateUserDto): Promise<string> {
     // 对密码进行hash加密
    const hashedPassword: string = await bcrypt.hash(dto.password, 10);

    try {
      // 保存加密后的密码
      dto.password = hashedPassword;
      // 传入参数,创建用户
      await this.prismaService.user.create({ data: dto });
      return '注册成功';
    } catch (error: unknown) {
      // 创建用户失败逻辑
      if (error instanceof Error) {
        throw new Error(`用户创建失败!${error.message}`);
      }
      throw new Error(`用户创建失败,未知错误!`);
    }
  }

  // 根据用户名查找用户
  async findUserByUsername(username: string): Promise<User | null> {
    return this.prismaService.user.findUnique({ where: { username } });
  }

  // 根据ID查找用户
  async findUserById(userId: number): Promise<User | null> {
    return this.prismaService.user.findUnique({ where: { id: userId } });
  }

  // 验证用户是否存在与密码是否正确
  async validateUser(username: string, password: string): Promise<User | null> {
    const user = await this.findUserByUsername(username);

    if (!user) return null;

    const isMatch = await bcrypt.compare(password, user.password);
    return isMatch ? user : null;
  }
}
```

## 权限模块

> jwt.startegy.ts

```ts
import { Injectable } from '@nestjs/common';
import { PassportStrategy } from '@nestjs/passport';
import { ExtractJwt, Strategy } from 'passport-jwt';

@Injectable()
export class JwtStrategy extends PassportStrategy(Strategy) {
  constructor() {
    super({
      jwtFromRequest: ExtractJwt.fromAuthHeaderAsBearerToken(),
      secretOrKey: process.env.JWT_SECRET,
      ignoreExpiration: false,
    });
  }

  async validate(payload: any) {
    return { userId: payload.sub, username: payload.username };
  }
}
```

> auth.module.ts

```ts
import { Module } from '@nestjs/common';
import { AuthService } from './auth.service';
import { AuthController } from './auth.controller';
import { UserService } from 'src/user/user.service';
import { JwtModule } from '@nestjs/jwt';
import { JwtStrategy } from './jwt.strategy';

@Module({
  imports: [
    JwtModule.register({
      secret: process.env.JWT_SECRET,
      signOptions: {
        expiresIn: process.env.JWT_EXPIRES_IN,
      },
    }),
  ],
  controllers: [AuthController],
  providers: [AuthService, UserService, JwtStrategy],
})
export class AuthModule {}
```

> auth.controller.ts

```ts
import { Controller, Post, Body } from '@nestjs/common';
import { AuthService } from './auth.service';
import { RegisterUserDto } from './dto/register-user.dto';
import { LoginUserDto } from './dto/login-user.dto';

@Controller('auth')
export class AuthController {
  constructor(private readonly authService: AuthService) {}

  // 注册
  @Post('register')
  async register(@Body() registerUserDto: RegisterUserDto) {
    return this.authService.register(registerUserDto);
  }

  // 登录
  @Post('login')
  async login(@Body() loginUserDto: LoginUserDto) {
    return this.authService.login(loginUserDto);
  }
}
```

> auth.service.ts

```ts
import { Injectable, UnauthorizedException } from '@nestjs/common';
import { UserService } from 'src/user/user.service';
import { JwtService } from '@nestjs/jwt';
import { RegisterUserDto } from './dto/register-user.dto';
import { LoginUserDto } from './dto/login-user.dto';
import { LoginVo } from './vo/login.vo';

@Injectable()
export class AuthService {
  constructor(
    private readonly userService: UserService,
    private readonly jwtService: JwtService,
  ) {}

  // 用户注册
  async register(registerUserDto: RegisterUserDto): Promise<string> {
    const exist = await this.userService.findUserByUsername(
      registerUserDto.username,
    );

    if (exist) throw new UnauthorizedException('用户名已被注册,换一个试试吧!');

    await this.userService.create(registerUserDto);
    return '注册成功!';
  }

  // 用户登录
  async login(loginUserDto: LoginUserDto) {
    const user = await this.userService.validateUser(
      loginUserDto.username,
      loginUserDto.password,
    );

    if (!user) throw new UnauthorizedException('邮箱或密码错误!');

    const payload = { sub: user.id, username: user.username };
    const token = this.jwtService.sign(payload);

    const loginVo = new LoginVo();
    loginVo.token = token;
    loginVo.id = user.id;
    loginVo.username = user.username;
    loginVo.email = user.email;
    loginVo.createdAt = user.createdAt;
    loginVo.updatedAt = user.updatedAt;

    return loginVo;
  }
}
```

